Searching 10 files for "noteStatus" (regex)

/Users/tenkai/Documents/Arduino/afx-01a/afx-01a.ino:
  110   Serial.println("sizeof testTimer1:" + String(sizeof(testTimer1)));
  111  
  112:  Serial.print("totalSizeofArrayVals: " + String(sizeof(sequence[0].stepPitch) + sizeof(sequence[0].stepVelocity) + sizeof(sequence[0].stepGlide) + sizeof(sequence[0].noteTimerMcs) + sizeof(sequence[0].noteStatus) + sizeof(sequence[0].noteTimer) + sizeof(sequence[0].noteData) + sizeof(sequence[0].gateLength) + sizeof(sequence[0].gateType) ));
  113  
  114   }

/Users/tenkai/Documents/Arduino/afx-01a/Sequencer.cpp:
  174        noteData[3] = stepVelocity[activeStep];
  175        noteTimer[activeStep] = 0;
  176:       // noteStatus indicates the status of the next note
  177        // 0 indicates not playing, not queued
  178        // 1 indicates the note is currently playing
  179        // 2 indicates the note is currently queued.
  180        // 3 indicates that the note is currently playing and currently queued
  181:       noteStatus[activeStep] = stepPitch[activeStep];
  182      }
  183    }
  ...
  188    // figure out which notes need to be turned off
  189    for(int i = 0; i < 128; i++){
  190:     if ( noteTimer[i] > noteTimerMcs[i] && noteStatus[i] == 1 ){
  191        // if the note is playing and has played out the gate length, end the note.
  192        noteData[4] = 1;
  193        noteData[1] = channel;
  194        n += 1;
  195:       noteData[n] = noteStatus[i];
  196:       noteStatus[i] = 0;
  197      } 
  198    }

/Users/tenkai/Documents/Arduino/afx-01a/Sequencer.h:
   36  		uint8_t 	programmedLength;
   37      uint8_t 	lastActiveStep;
   38: 		uint8_t 	noteStatus[128];				// boolean which tells if the note is playing or not
   39      elapsedMicros	noteTimer[128];  // timer for each note, set to 0 when note is activated, times when noteOff event arrives.
   40  		elapsedMicros stepTimer;			// timer for step to step

7 matches across 3 files


Searching 10 files for "stepPitch" (regex)

/Users/tenkai/Documents/Arduino/afx-01a/afx-01a.ino:
   43  //int8_t gateType[128];
   44  //bool    stepActive[128] = {1,1,1,1,1,1,1,1};         // which steps are active
   45: //uint8_t stepPitch[128];        // the pitch the step will play
   46  //uint8_t stepVelocity[128];     // the velocity of the step
   47  //uint8_t stepLength[128] = {1,1,1,1,1,1,1,1};        // the length of the step in 1/16th note
   ..
  107   Serial.println("sizeof testTimer1:" + String(sizeof(testTimer1)));
  108  
  109:  //Serial.print("totalSizeofArrayVals: " + String(sizeof(sequence[0].stepPitch) + sizeof(sequence[0].stepVelocity) + sizeof(sequence[0].stepGlide) + sizeof(sequence[0].noteTimerMcs) + sizeof(sequence[0].noteStatus) + sizeof(sequence[0].noteTimer) + sizeof(sequence[0].noteData) + sizeof(sequence[0].gateLength) + sizeof(sequence[0].gateType) ));
  110  
  111   }

/Users/tenkai/Documents/Arduino/afx-01a/clock.ino:
  208    // length:       1   1   2       1   1   2       1   1   2
  209    // stepActive:   X   X   X       -   X   -       -   X   -  
  210:   // stepPitch:    34  34  53      52  43  35      35  32  35 
  211    // stepVelocity: 53  51  125     53  64  12      35  59  12 
  212  /// SCENERIO 2: steps are based on beats <<<--- Gonna do this one, its easier to start with
  ...
  222    // length:       1   1   2   1   1   1   2   1   1   1   2
  223    // stepActive:   X   X   X   -   -   X   -   -   -   X   -  
  224:   // stepPitch:    34  34  53  0   52  43  35  0   35  32  35 
  225    // stepVelocity: 53  51  125 0   53  64  12  0   35  59  12 
  226  
  ...
  237  
  238    synth.allNotesOff(0);
  239:   synth.noteOn(0, stepPitch[activeStep], 64);   
  240  */
  241  

/Users/tenkai/Documents/Arduino/afx-01a/display.ino:
  126      }
  127      display.setTextSize(2);
  128:     display.print(String(midiNotes[sequence[selectedSequence].stepPitch[selectedStep]]));
  129      display.setTextColor(WHITE);
  130      display.setTextSize(1);
  ...
  200            pixels.setPixelColor(i, pixels.Color(0,0,0));
  201          } else {
  202:           pixels.setPixelColor(i, Wheel( sequence[selectedSequence].getStepPitch(i) ) );
  203          }
  204        }

/Users/tenkai/Documents/Arduino/afx-01a/input.ino:
  163        case 0:
  164        // just change the note
  165:         if (knob2Buffer + sequence[selectedSequence].getStepPitch(selectedStep) < 0){
  166            // you can turn off a note by turning the value to 0
  167            // turn off a note by setting gate type and pitch to 0 
  168            sequence[selectedSequence].gateType[selectedStep] = 0;
  169:           sequence[selectedSequence].setStepPitch(selectedStep, 0);
  170          } else {
  171            if(sequence[selectedSequence].gateType[selectedStep] == 0){
  ...
  174            } 
  175            // and finally set the new step value!
  176:           sequence[selectedSequence].setStepPitch(selectedStep, positive_modulo(stepModeBuffer + knob2Buffer, 127));
  177          }
  178          break;
  ...
  314      knob2.write(0);
  315      knob2previousValue = 0;
  316:     stepModeBuffer = sequence[selectedSequence].getStepPitch(selectedStep);
  317    }
  318  }
  ...
  343            for(int i=0; i <16; i++){
  344              sequence[selectedSequence].gateType[i] = random(2);
  345:             sequence[selectedSequence].setStepPitch(i, random(1, 127));
  346            }
  347            break;

/Users/tenkai/Documents/Arduino/afx-01a/Sequencer.cpp:
   17  		gateLength[i] = 1;
   18  		gateType[i] = 0;
   19:     stepData[i].stepPitch = 0;
   20      stepData[i].beat = 0;
   21      stepData[i].offset = 0;
   ..
   47  };		
   48  
   49: void Sequencer::setStepPitch(uint8_t step, uint8_t pitch){
   50: 	stepData[step].stepPitch = pitch;
   51  };
   52  
   ..
  171        noteData[0] = 1;
  172        noteData[1] = channel;
  173:       noteData[2] = stepData[activeStep].stepPitch;
  174        noteData[3] = stepVelocity[activeStep];
  175        stepData[activeStep].stepTimer = 0;
  ...
  179        // 2 indicates the note is currently queued.
  180        // 3 indicates that the note is currently playing and currently queued
  181:       stepData[activeStep].noteStatus = stepData[activeStep].stepPitch;
  182      }
  183    }
  ...
  201  }
  202  
  203: uint8_t Sequencer::getStepPitch(uint8_t step){
  204: 	return stepData[step].stepPitch;
  205  };
  206  

/Users/tenkai/Documents/Arduino/afx-01a/Sequencer.h:
   10  		void setTempo(uint8_t bpm);
   11  		void setScale(uint8_t scaleIndex);		
   12: 		void setStepPitch(uint8_t step, uint8_t pitch);
   13  		void setGateLength(uint8_t step, uint8_t length);
   14  		void setGateType(uint8_t step, uint8_t gate);
   ..
   21  		void resetSequenceTimer();
   22  		uint8_t * runSequence();
   23: 		uint8_t getStepPitch(uint8_t step);
   24  		uint8_t pulseTracker;		// keeps track of how long the sequence has been playing
   25  		uint8_t	activeStep;
   ..
   81  
   82  		// variables to replace with stepData array
   83: 		//uint8_t stepPitch[128];      // the pitch the step will play
   84  		uint8_t stepVelocity[128];   // the velocity of the step
   85  		uint8_t	stepGlide[128];			// 0-128 value that defines the fraction of the gate length that the note glides

22 matches across 6 files
